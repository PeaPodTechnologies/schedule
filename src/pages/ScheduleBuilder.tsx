import { FC, useState } from 'react';
import './ScheduleBuilder.css';
import InputBlock from '../atoms/InputBlock';
import AddParameter from '../molecules/AddParameter';
import ParameterBlock from '../molecules/ParameterBlock';
import { v4 as uuid } from 'uuid';
import { PhaseTypes } from '../atoms/types';
import { PEAPODAPI_REVISION, EnvironmentSchedule, SchedulePhase } from '@peapodtech/types';

type ScheduleBuilderProps = {};

/**
 * this object's purpose is to contain/manage it's parameter blocks. those parameter blocks will modify a parameter
 * to the user's desire.
 *
 * it will have an export function that will turn all of the parameter blocks into a proper schedule format
 */
const ScheduleBuilder: FC<ScheduleBuilderProps> = _ => {
	const [schedule, setSchedule] = useState<EnvironmentSchedule>({
		// the initial state of the object
		id: 'peapod-schedule-' + uuid(),
		name: undefined,
		revision: PEAPODAPI_REVISION,
		parameters: {}
	});

	// WIP: converting the parameterblocks into a proper EnvironmentSchedule, ignore
	const downloadSchedule = () => {
		// BLOB-ify
		const blob = new Blob([JSON.stringify(schedule, null, 2)], { type: 'application/json' });

		// Give it a URL
		const href = URL.createObjectURL(blob);

		// Create a download button, click it, remove it, and clean up
		const a = document.createElement('a');
		a.href = href;
		a.download = `${schedule.id}.json`;
		document.body.appendChild(a);

		a.click();

		document.body.removeChild(a);
		URL.revokeObjectURL(href);
	};

	// render function
	return (
		<div className="ScheduleBuilder">
			{/* NO input for ID, autogenerated */}
			<InputBlock
				value={schedule.id}
				label="id"
				onBlur={newId => {
					setSchedule(old => {
						let newSchedule = { ...old };

						// updating the id of the schedule
						newSchedule.id = newId;

						// returning the new state
						return newSchedule;
					});
				}}
			></InputBlock>

			{/* add prop `onUpdate(name: string) => void` that sets schedule.name */}
			<InputBlock
				value={schedule.name ?? ''}
				label="name"
				onBlur={newName => {
					setSchedule(old => {
						let newSchedule = { ...old };

						// updating the name of the schedule
						newSchedule.name = newName;

						// returning the new state
						return newSchedule;
					});
				}}
			></InputBlock>

			{/* NO input, uses latest */}
			<InputBlock readonly={true} label="revision" onBlur={() => null}></InputBlock>

			{/* the purpose of this is to add a new entry into the parameterblock array */}
			<AddParameter
				addParameter={() => {
					// generating a new id for each parameter until it is user defined
					let parameterEntry = uuid();
					setSchedule(old => {
						// getting all of the current parameters
						let newParameters = { ...old.parameters };

						// inserting the new parameter object into the global state
						newParameters[parameterEntry] = [
							{
								type: PhaseTypes.PIECEWISE,
								end: 0,
								targets: [
									{
										value: 0,
										timestamp: 0
									}
								]
							}
						];

						// logging
						console.log(
							`create ${parameterEntry}: ${JSON.stringify(newParameters[parameterEntry])}`
						);
						return { ...old, parameters: newParameters };
					});
				}}
			/>

			<div>
				<button
					onClick={() => {
						console.log(schedule.parameters);
					}}
				>
					View Params
				</button>
				{/* <button
					onClick={() => {
						// showing verbose output of the program if toggled
						debug = !(debug ?? false);
					}}
				>
					{debug ?? false ? 'Enable Debug' : 'Disable Debug'}
				</button> */}
			</div>

			<table>
				<thead></thead>
				<tbody>
					{Object.entries(schedule.parameters).map(([parameter, phases]) => (
						// creating visual representations of each parameter
						<ParameterBlock
							parameter={parameter}
							phases={phases}
							update={(payload, ...keys) => {
								if (payload === 'name') {
									console.log(`rename ${parameter} to ${keys[0]}`);
								} else {
									console.log(
										`update ${parameter}${keys
											.map(key => {
												return `[${key}]`;
											})
											.join('')} = ${payload}`
									);
								}

								setSchedule(old => {
									// getting all of the current parameters
									let newParameters = { ...old.parameters };

									/// removing the object from the global state

									if (payload === 'name') {
										// getting the name from the keys
										let name = keys[0];

										// detecting name collisions
										if (Object.keys(newParameters).includes(name)) {
											alert(
												`Cannot rename ${parameter} to ${name} because ${name} already exists.`
											);
											return old;
										}

										// changing a parameter's name
										newParameters = Object.fromEntries(
											// the goal of this is to update the object's key **in place**
											// this prevents the parameters moving around on screen
											Object.entries(newParameters).map(([key, value]) => {
												return key === parameter ? [name, value] : [key, value];
											})
										);
									} else {
										// navigating to the right context
										let context: any = newParameters[parameter];

										// getting the index of the thing we want to remove
										let key: number = keys.pop();

										// walking the object
										keys.forEach(key => {
											context = context[key];
										});

										// updating the value of the object
										context[key] = payload;
									}

									// returning the new global state
									return { ...old, parameters: newParameters };
								});
							}}
							create={(payload, ...keys) => {
								console.log(
									`create ${parameter}${keys
										.map(key => {
											return `[${key}]`;
										})
										.join('')}[+1] = ${JSON.stringify(payload)}`
								);
								setSchedule(old => {
									// getting all of the current parameters
									let newParameters = { ...old.parameters };

									/// inserting the new parameter object into the global state

									// navigating to the right context
									let context: any = newParameters[parameter];

									keys.forEach(key => {
										context = context[key];
									});

									// adding the payload
									(context as SchedulePhase[]).push(payload);

									// returning the new global state
									return { ...old, parameters: newParameters };
								});
							}}
							delete={(...keys) => {
								console.log(
									`delete ${parameter}${keys
										.map(key => {
											return `[${key}]`;
										})
										.join('')}`
								);

								setSchedule(old => {
									// getting all of the current parameters
									let newParameters = { ...old.parameters };

									/// removing the object from the global state

									if (keys.length === 0) {
										// we are removing a parameter
										delete newParameters[parameter];
									} else {
										// navigating to the right context
										let context: any = newParameters[parameter];

										// getting the index of the thing we want to remove
										let index: number = keys.pop();

										// walking the object
										keys.forEach(key => {
											context = context[key];
										});

										// removing the target object
										(context as SchedulePhase[]).splice(index, 1);
									}

									// returning the new global state
									return { ...old, parameters: newParameters };
								});
							}}
						/>
					))}
				</tbody>
			</table>
			{/* DOWNLOAD BUTTON: Create a component with an `onClick: (void)=>void` callback parameter set to {downloadSchedule} */}
		</div>
	);

	// need an export to json function this function will look through its children and create a schedule.json from them
};

export default ScheduleBuilder;
